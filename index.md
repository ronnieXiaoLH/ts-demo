# TypeScript

## TypeScript 的优势

- 编译时静态类型检测
- 自动提示更清晰明确
- 引入了泛型和一系列的 TS 特有类型
- 强大的 d.ts 声明文件
- 轻松编译成 JS 文件
- 灵活性高

## TypeScript 核心语法

### 类型注解和类型推断

类型注解是一种明确地告诉 TypeScript 变量的类型的方式。可以在声明变量、函数参数、函数返回值等地方添加类型注解。

类型推断是 TypeScript 编译器根据代码上下文自动推断变量的类型。在大多数情况下，TypeScript 能够根据赋值语句、函数返回值等自动推断变量的类型。

### 常用的 24 种 TypeScript 类型

- 基本类型：number、string、boolean、symbol、null、undefined
- 根类型：Object、{}
- 对象类型：Array、object、Function
- 枚举：enum
- 其他特殊类型：any、unknown、never、void、元组(tuple)、可变元组
- 合成类型：联合类型、交叉类型
- 字面量数据类型

### any 和 unknown

`any` 类型表示任何类型的值，允许在编写代码时，绕过 TypeScript 的静态类型检查。

`unknown` 类型要求在使用前进行类型检查，已确保类型的正确性。

相同点：

- `any` 类型和 `unknown` 类型是任何类型的父类，所以任何类型的变量都可以赋值给 `any` 类型和 `unknown` 类型的变量。

不同点：

- 类型检查：`any` 类型不要求进行类型检查（`any` 类型的变量可以获取任何属性和方法），而 `unknown` 类型要求在使用前进行类型检查（`unknown` 类型的变量不可以直接获取任何属性和方法）。
- 类型推导：当使用 `any` 类型时，TypeScript 不会提供任何关于变量的类型信息；当使用 `unknown` 类型时，TypeScript 会记住变量的类型，但要求进行显示的类型检查。
- 类型安全：由于 `any` 类型的灵活性，可能会导致类型错误，而 `unknown` 类型的使用要更安全，因为在使用之前需要进行类型检查。

### interface 和 type

相同点：

- 都可以用于定义对象的属性和方法以及其对应的类型。

不同点：

- 可读性：`interface` 更常用于表示对象的结构，`type` 通常用于更通用的目的，可以表示联合类型 、交叉类型等。
- 合并声明：当声明同名的 `interface` 或 `type` 时，`interface` 会自动合并，`type` 不会。
- 类型范围：`type` 可以定义任何类型，`type` 可以使用交叉类型（`&`）和联合类型（`|`）进行更复杂的类型操作。
- 继承：`interface` 可以继承，`type` 无法继承

### null 和 undefined

- `null` 表示一个空值或者没有对象指定。
- `undefined` 表示一个未定义的值。
- `any`、`unknown`、`undefined` 类型的变量可以接收 undefined 的值。
- `any`、`unknown`、`null` 类型的变量可以接收 null 的值。

### 元组

元组（Tuple）是一种有序的数据结构，它允许表示一个固定长度和固定类型的数组。与普通的数组不同，元组中的每个位置可以有不同的数据类型。

- 元组的长度和每个位置的数据类型必须与定义时一致，不能多也不能少。
- 访问元组的元素时，不能超过其长度。
- 元组的各个元素可以具有不同的数据类型，但访问时需要根据定义的类型进行使用。

### 可变元组

可变元组是指具有不固定长度的元组。使用可变元组时，需要使用...语法，称为剩余元素（Rest Elements），来表示元组中的可变部分。

### 如何将 TS 数组和数组中的每个元素定义为只读

```ts
// 方式1：
const arr = [1, 2, 3] as const
// 方式2：
const arr2: readonly number[] = [1, 2, 3]
```

### 类型转换

类型转换是将一个类型的值显式转换为另一种类型的操作，有两种主要的类型转换方式：

- 类型断言
- 类型转换函数

### 类型守卫

类型守卫是一种在代码中使用条件语句来明确一个变量的类型的技术。以下是一些常见的类型守卫方式：

- typeof 类型守卫
- instanceof 类型守卫
- in 运算符类型守卫
- 自定义类型守卫
